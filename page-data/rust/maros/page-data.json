{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/rust/maros/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Tech Notes"}},"markdownRemark":{"id":"654ee414-89a5-5451-948d-599d14a7ce5b","excerpt":"is a Rust way of  - writing a code that creates another code.  and  are examples of macroses. Internally they execute more code, that has to be\nwritten manuallyâ€¦","html":"<p><code class=\"language-text\">Macros</code> is a Rust way of <code class=\"language-text\">metaprogramming</code> - writing a code that creates another code.</p>\n<p><code class=\"language-text\">println!</code> and <code class=\"language-text\">vec!</code> are examples of macroses. Internally they execute more code, that has to be\nwritten manually. e.g. with <code class=\"language-text\">vec!</code> it is possible to create an instance of <code class=\"language-text\">Vec&lt;T></code> and add some\nvalues inside of it during single statement.</p>\n<p>Macros are similar to functions, but the bigges difference between them in moment of execution -\n<code class=\"language-text\">function</code> is executed in runtime, whereas <code class=\"language-text\">macros</code> is executed during compile time. That quality\nallows for example implement trait for some type inside of a <code class=\"language-text\">macros</code>.</p>\n<p>The main con for <code class=\"language-text\">macros</code> is higher complexity to write and read. Also macros have to be defined\nstrictly before place, where it is used.</p>\n<p><strong>Macros types in Rust:</strong></p>\n<ul>\n<li>declarative - declared with <code class=\"language-text\">macro_rules!</code></li>\n<li>procedural:\n<ul>\n<li>Custom <code class=\"language-text\">#[derive]</code> macros that specify code added with the derive attribute used on structs\nand enums</li>\n<li><code class=\"language-text\">Attribute-like</code> macros that define custom attributes usable on any item</li>\n<li><code class=\"language-text\">Function-like</code> macros that look like function calls but operate on the tokens specified as\ntheir argument</li>\n</ul>\n</li>\n</ul>\n<h2>Declarative macros</h2>\n<p><code class=\"language-text\">Declarative macros</code> are something similar to <code class=\"language-text\">match</code> expressions, which allows to get values,\ncompare it with some value and then execute required branch of code and do it on compilation stage.</p>\n<p><code class=\"language-text\">declarative macros</code> are defined with <code class=\"language-text\">macro_rules!</code>.</p>\n<p>Consider for example <code class=\"language-text\">vec!</code> macro, which allows to create filled <code class=\"language-text\">Vec&lt;T></code> instance:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[macro_export]</span>\n<span class=\"token macro property\">macro_rules!</span> vec <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">(</span> $<span class=\"token punctuation\">(</span> <span class=\"token variable\">$x</span><span class=\"token punctuation\">:</span><span class=\"token fragment-specifier punctuation\">expr</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token operator\">*</span> <span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> temp_vec <span class=\"token operator\">=</span> <span class=\"token class-name\">Vec</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            $<span class=\"token punctuation\">(</span>\n                temp_vec<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$x</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">)</span><span class=\"token operator\">*</span>\n            temp_vec\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">#[macro_export]</code> allows to import created macro into usage scope. <code class=\"language-text\">macro_rules!</code> is a beginning of\nmacro definition. After we define the name of the macro and then starts the scope of the macro.\nMacro definition has a structure similar to <code class=\"language-text\">match</code> expresstion, where it is possible to define\nseveral arm cases with pattern on the left side and executable code on the right.</p>\n<p>Here <code class=\"language-text\">( $( $x:expr ),* )</code> is a pattern. When user enters inside of a macro value data, which will\nmatch this pattern, the code, assosiated with it will be executed.</p>\n<p><strong>Pattern syntax:</strong></p>\n<p>Pattern begins with <code class=\"language-text\">(...)</code>. Inside <code class=\"language-text\">$(...)</code> captures entered value. <code class=\"language-text\">$x:expr</code> defines a name <code class=\"language-text\">$x</code>\nfor captured value. <code class=\"language-text\">expr</code> is a Rust expression. <code class=\"language-text\">,</code> indicates, that after captured expression\ncomma character may appear. And finally <code class=\"language-text\">*</code> indicates, that this patter may be repetetive.</p>\n<p>So for <code class=\"language-text\">vec![1, 2, 3];</code> this pattern will capture numbers 1, 2 and 3 repetitively.</p>\n<p>Inside of arm executable code we defined <code class=\"language-text\">$(...)*</code>, which means that code inside of it will be\nemmitted for every <code class=\"language-text\">$( $x:expr )</code> pattern match.</p>\n<p>That way, after this macro will generate actual Rust code, it will emit:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> temp_vec <span class=\"token operator\">=</span> <span class=\"token class-name\">Vec</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    temp_vec<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    temp_vec<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    temp_vec<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    temp_vec\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>References</h2>\n<ul>\n<li><a href=\"https://doc.rust-lang.org/stable/book/ch19-06-macros.html\">Macros - The Rust Programming Language</a></li>\n</ul>","frontmatter":{"title":"Rust - Macros","date":"March 16, 2022","description":"Creation and working with macroses in Rust"}},"previous":{"fields":{"slug":"/rust/functions/"},"frontmatter":{"title":"Rust - Functions"}},"next":{"fields":{"slug":"/javascript/ts-project-setup/"},"frontmatter":{"title":"JavaScript/TypeScript Project Setup"}}},"pageContext":{"id":"654ee414-89a5-5451-948d-599d14a7ce5b","previousPostId":"1184b19b-5203-5820-b48c-0d89fa0a45e5","nextPostId":"b8c5d0a3-3040-54b0-a781-8e08cdb27dc0"}},
    "staticQueryHashes": ["2063783301","2841359383","3274528899"]}